## 🔸 2022-09-06 화요일

## [객체지향프로그래밍]

### 1. Object 클래스

- finalize 메서드
    - clone(), equals(), hashcode(), toString()처럼 호출하는 메서드가 아님
    - 이 객체가 Heap 메모리에서 해제될 때, 가비지 콜렉터에서 호출되는 메서드
    - 리소스 해제, 안 닫혀있는 소켓 닫기 역할
    - 예외처리 많이 들어감
    - 정리 : 직접 호출되는 메서드가 아니라 인스턴스가 힙 메모리에서 해제될 때, 가비지 콜렉터에서 수행되는 메서드

<br>

### 2. Class 클래스

- 자바의 모든 클래스와 인터페이스는 컴파일 후 class 파일로 생성됨
- class 파일에는 객체의 정보(멤버 변수, 메서드, 생성자 등)가 포함되어 있음
- Class 클래스는 컴파일 된 class 파일에서 객체의 정보를 가져올 수 있음
- 실제 Class 클래스를 갖고 코딩하는 경우는 많지 않음
- 이미 로컬에 내가 사용하고자 하는 라이브러리가 있고, 라이브러리들이 자료형을 모두 알고 있는 상태이기 때문
- 대부분의 사용하는 경우는 리플렉션(Reflection) 프로그래밍, 로컬에 자료형 혹은 모듈이 없는 경우, 동적 로딩일 경우 사용

<br>

- Class 클래스 가져오기(3 가지)

```
  #1
  String s = new String();
  Class c = s.getClass();
  
  #2
  Class c = String.Class;
  
  #3
  Class c = Class.forName("java.lang.String");      // 동적 로딩
```

- #1 => getClass()는 `Object 메서드`, 따라서 어느 클래스에서나 사용 가능, 클래스 변수를 가져올 수 있음
- #2 => `String.` 찍은 후 바로 Class 가져올 수 있음. 이 때, 클래스는 컴파일이 된 상태
- #3 => (가장 많이 사용함), "클래스 풀네임"이 들어간 클래스가 로딩(해당 구문이 실행될 때)
    - 대부분 컴파일 시 어떤 것을 사용할 것이다라는 것이 이미 바인딩 됨, 정적 로딩
    - `Class.forName()`은 런타임때 바인딩 됨(동적 로딩)
    - `("java.~")`에 해당되는 클래스가 로컬에 있으면, 그 때 호출해서 사용 가능
    - `("java.lang.String")` => String 이기 때문에 replace(대체) 가능
    - java.lang.double, java.lang.float 등으로 변수에 따라 대체 가능
    - 자바에서 JDBC 사용 시 관련 DB 라이브러리(Oracle, MSSQL 등)들을 모두 정적으로 연결해서 컴파일 할 수 없음
    - 그럴 경우 너무 많은 라이브러리들을 연결해서 컴파일 해야하기 때문
    - `동적 로딩의 장점` - 내가 필요로 하는 라이브러리를 선택해 호출할 수 있도록 함(런타임 시 상황에 맞게 원하는 라이브러리를 매칭)
    - `동적 로딩의 단점` - 호출하려는 타입에 오타 발생 시 로딩하다가 클래스가 당연히 존재하지 않기 때문에 에러 발생으로 런타임 시 죽을 수 있음
